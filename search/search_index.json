{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Decentralized Flexible Organization - DFO Microservices on Ethereum \ud83d\udc7d for Independent Dapps ugradable by voting \ud83d\ude31 Authors: Marco Vasapollo ( @vasapower ) and Alessandro Mario Lagan\u00e0 Toschi ( @alessandromlt ) | bro@buidl.life Join us: https://www.notion.so/Community-Guidelines-a03ceeab28254eb3944ab85320be70de The Basis DFO is a new concept that reshapes the way to build Decentralized Applications (DApps), enabling the creation of extendible, improvable and fixable Systems , using an approach called Smart Contract as Microservice which avoids the slow and dangerous monolythic Smart Contract development procedures. Because of everything is completely deployed and running on the Ethereum blockchain , the need of Centralized or Distributed Servers is finally bypassed. In DFO, every DApp functionality is a Smart Contract acting like a Microservice , which can also be stateless and therefore reusable in different applications. Instead of directly using Smart Contracts functions, calling their specific address, in DFO you will interact with the Proxy which will keep track of the latest correct versions of all Microservices (located in different addresses) composing your DApp. No matter how many Microservices will you attach, detach or replace to a DFO since its creation. The address of your Dapp will be always the same, forever . DFO is completely Community Driven . This means that every strategic decision about the DApp Functionalities and their future is taken by its Token Holders. In fact, to add/replace/remove a Microservice, the proposer must interact with the Proxy to start a Survey which can be voted by the ones holding the ERC20 Voting Tokens linked to that DFO, staking them to accept or refuse the proposal. The governance rules (that establish the success or the failure of a Survey) are, in turn, Functionalities of the DFO itself located within Microservices that can be updated too... through Proposals! The Proxy, the Voting Token, the Proposals, the Governance Rules and some other Smart Contracts are all the components that make up every single DFO. Every DFO is a bunch of Smart Contracts cooperating each other to let users: using Functionalities in both Read and Write Mode; proposing to add/remove/replace these Functionalities through Surveys; voting to Accept/Refuse them through Voting Tokens. Even the Smart Contracts of a DFO can be updated to address bug fixes or to expand the potential of the protocol just making a Proposal to the Token Holders Community. To let people create and use DFOs, we built DFOHub , our R&D community-driven project that aims to improve the DFO protocol itself by managing its progress through a DFO maintained by its own token holders, who can propose or vote for improvements and bug fixes with anonymous, decentralized and very easy steps. DFOHub extremely facilitates the deployment processes for a new DFO, you can exploit it in two ways: using the easy steps of the wizard we coded on DFOHub ; [ COMING SOON ] using the integration SDK which lets you easily integrate DFO protocol capabilities in your DApp.","title":"Home"},{"location":"#decentralized-flexible-organization-dfo","text":"","title":"Decentralized Flexible Organization - DFO"},{"location":"#microservices-on-ethereum-for-independent-dapps-ugradable-by-voting","text":"","title":"Microservices on Ethereum \ud83d\udc7d for Independent Dapps ugradable by voting  \ud83d\ude31"},{"location":"#authors-marco-vasapollo-vasapower-and-alessandro-mario-lagana-toschi-alessandromlt-amp98amp114amp111amp64amp98amp117amp105amp100amp108amp46amp108amp105amp102amp101","text":"","title":"Authors: Marco Vasapollo (@vasapower) and Alessandro Mario Lagan\u00e0 Toschi (@alessandromlt) | \u0002amp\u0003#98;\u0002amp\u0003#114;\u0002amp\u0003#111;\u0002amp\u0003#64;\u0002amp\u0003#98;\u0002amp\u0003#117;\u0002amp\u0003#105;\u0002amp\u0003#100;\u0002amp\u0003#108;\u0002amp\u0003#46;\u0002amp\u0003#108;\u0002amp\u0003#105;\u0002amp\u0003#102;\u0002amp\u0003#101;"},{"location":"#join-us-httpswwwnotionsocommunity-guidelines-a03ceeab28254eb3944ab85320be70de","text":"","title":"Join us: https://www.notion.so/Community-Guidelines-a03ceeab28254eb3944ab85320be70de"},{"location":"#the-basis","text":"DFO is a new concept that reshapes the way to build Decentralized Applications (DApps), enabling the creation of extendible, improvable and fixable Systems , using an approach called Smart Contract as Microservice which avoids the slow and dangerous monolythic Smart Contract development procedures. Because of everything is completely deployed and running on the Ethereum blockchain , the need of Centralized or Distributed Servers is finally bypassed. In DFO, every DApp functionality is a Smart Contract acting like a Microservice , which can also be stateless and therefore reusable in different applications. Instead of directly using Smart Contracts functions, calling their specific address, in DFO you will interact with the Proxy which will keep track of the latest correct versions of all Microservices (located in different addresses) composing your DApp. No matter how many Microservices will you attach, detach or replace to a DFO since its creation. The address of your Dapp will be always the same, forever . DFO is completely Community Driven . This means that every strategic decision about the DApp Functionalities and their future is taken by its Token Holders. In fact, to add/replace/remove a Microservice, the proposer must interact with the Proxy to start a Survey which can be voted by the ones holding the ERC20 Voting Tokens linked to that DFO, staking them to accept or refuse the proposal. The governance rules (that establish the success or the failure of a Survey) are, in turn, Functionalities of the DFO itself located within Microservices that can be updated too... through Proposals! The Proxy, the Voting Token, the Proposals, the Governance Rules and some other Smart Contracts are all the components that make up every single DFO. Every DFO is a bunch of Smart Contracts cooperating each other to let users: using Functionalities in both Read and Write Mode; proposing to add/remove/replace these Functionalities through Surveys; voting to Accept/Refuse them through Voting Tokens. Even the Smart Contracts of a DFO can be updated to address bug fixes or to expand the potential of the protocol just making a Proposal to the Token Holders Community. To let people create and use DFOs, we built DFOHub , our R&D community-driven project that aims to improve the DFO protocol itself by managing its progress through a DFO maintained by its own token holders, who can propose or vote for improvements and bug fixes with anonymous, decentralized and very easy steps. DFOHub extremely facilitates the deployment processes for a new DFO, you can exploit it in two ways: using the easy steps of the wizard we coded on DFOHub ; [ COMING SOON ] using the integration SDK which lets you easily integrate DFO protocol capabilities in your DApp.","title":"The Basis"},{"location":"CONTRIBUTING/","text":"Contributing guidelines Table of Contents Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs Coding Style Solidity Solidity portions of the codebase adhere follow the official Solidity Styleguide JavaScript Python Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings. Documentation New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve mkdocs To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"","title":"Contributing guidelines"},{"location":"CONTRIBUTING/#table-of-contents","text":"Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs","title":"Table of Contents"},{"location":"CONTRIBUTING/#coding-style","text":"","title":"Coding Style"},{"location":"CONTRIBUTING/#solidity","text":"Solidity portions of the codebase adhere follow the official Solidity Styleguide","title":"Solidity"},{"location":"CONTRIBUTING/#javascript","text":"","title":"JavaScript"},{"location":"CONTRIBUTING/#python","text":"Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings.","title":"Python"},{"location":"CONTRIBUTING/#documentation","text":"New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve","title":"Documentation"},{"location":"CONTRIBUTING/#mkdocs","text":"To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"mkdocs"},{"location":"contracts/ICommonUtilities/","text":"Contract ICommonUtilities Path: contracts/ICommonUtilities.sol Version: 1 Title: Common Utilities Collection of simple utilities Methods compareStrings(string,string) Compare to strings toAddress(bytes) Convert bytes address to address toLowerCase(string) Convert a string to lowercase toString(address) Convert address to string toString(uint256) Convert uint to string toUint256(bytes) Convert bytes address to uint","title":"ICommonUtilities"},{"location":"contracts/ICommonUtilities/#contract-icommonutilities","text":"Path: contracts/ICommonUtilities.sol Version: 1 Title: Common Utilities Collection of simple utilities","title":"Contract ICommonUtilities"},{"location":"contracts/ICommonUtilities/#methods","text":"","title":"Methods"},{"location":"contracts/ICommonUtilities/#comparestringsstringstring","text":"Compare to strings","title":"compareStrings(string,string)"},{"location":"contracts/ICommonUtilities/#toaddressbytes","text":"Convert bytes address to address","title":"toAddress(bytes)"},{"location":"contracts/ICommonUtilities/#tolowercasestring","text":"Convert a string to lowercase","title":"toLowerCase(string)"},{"location":"contracts/ICommonUtilities/#tostringaddress","text":"Convert address to string","title":"toString(address)"},{"location":"contracts/ICommonUtilities/#tostringuint256","text":"Convert uint to string","title":"toString(uint256)"},{"location":"contracts/ICommonUtilities/#touint256bytes","text":"Convert bytes address to uint","title":"toUint256(bytes)"},{"location":"contracts/IDoubleProxy/","text":"Contract IDoubleProxy Path: contracts/IDoubleProxy.sol Version: 1 Title: Double Proxy Interface None Methods init(address[],address) Initializer logic used during the constructor call Params currentProxy : Address of the current proxy proxies : Array of address of the old proxies, only used in legacy scenarios. Can be left empty. isProxy(address) Check if the address is or has been a proxy proxies() Retrieve all the proxies proxies(uint256,uint256) Retrieve a portion of the proxies Params offset : End Position start : Start Position proxiesLength() GET the number of proxies proxy() GET the proxy setProxy() SET the proxy","title":"IDounleProxy"},{"location":"contracts/IDoubleProxy/#contract-idoubleproxy","text":"Path: contracts/IDoubleProxy.sol Version: 1 Title: Double Proxy Interface None","title":"Contract IDoubleProxy"},{"location":"contracts/IDoubleProxy/#methods","text":"","title":"Methods"},{"location":"contracts/IDoubleProxy/#initaddressaddress","text":"Initializer logic used during the constructor call","title":"init(address[],address)"},{"location":"contracts/IDoubleProxy/#params","text":"currentProxy : Address of the current proxy proxies : Array of address of the old proxies, only used in legacy scenarios. Can be left empty.","title":"Params"},{"location":"contracts/IDoubleProxy/#isproxyaddress","text":"Check if the address is or has been a proxy","title":"isProxy(address)"},{"location":"contracts/IDoubleProxy/#proxies","text":"Retrieve all the proxies","title":"proxies()"},{"location":"contracts/IDoubleProxy/#proxiesuint256uint256","text":"Retrieve a portion of the proxies","title":"proxies(uint256,uint256)"},{"location":"contracts/IDoubleProxy/#params_1","text":"offset : End Position start : Start Position","title":"Params"},{"location":"contracts/IDoubleProxy/#proxieslength","text":"GET the number of proxies","title":"proxiesLength()"},{"location":"contracts/IDoubleProxy/#proxy","text":"GET the proxy","title":"proxy()"},{"location":"contracts/IDoubleProxy/#setproxy","text":"SET the proxy","title":"setProxy()"},{"location":"contracts/IMVDFunctionalitiesManager/","text":"Contract IMVDFunctionalitiesManager Path: contracts/IMVDFunctionalitiesManager.sol Version: 1 Title: Interface for the Functionalities Manager None Methods addFunctionality(string,address,uint256,address,bool,string,string,bool,bool) Add a functionality to the Functionalities Manager Params codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain addFunctionality(string,address,uint256,address,bool,string,string,bool,bool,uint256) Replace a Functionality in the Functionalities Manager Params codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place position : Position of the Functionality to replace returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain functionalityNames() GET all Functionalities Names (IDs) functionalityNames(uint256,uint256) GET all Functionalities Names (IDs) in a portion of the array functionalityToJSON(string) Given a Functionality ID return its JSON encoded version getFunctionalitiesAmount() GET the amount of functionalities present in the Functionalities Manager getProxy() GET the proxy hasFunctionality(string) Check that the FunctionalitiesManager has a specific Functionality Params codeName : ID of the Functionality to be checked Returns output : Boolean flag indicating wether the Functionalities Manager has the given Functionality. init(address,uint256,address,uint256,address,uint256,address,uint256,address) Initializer logic used during the constructor call Params checkVoteResultFunctionalityAddress : Address for the Functionality that controls the check for determining if a Proposal was successful or it failed checkVoteResultSourceLocationId : ROBE id getEmergencyMinimumBlockNumberFunctionalityAddress : Address for the Functionality that controls the block duration of emergency proposals getEmergencyMinimumBlockNumberSourceLocationId : ROBE id getEmergencySurveyStakingFunctionalityAddress : Address for the Functionality that controls the minimum amount of vote to be staked in order to start an Emergency Proposal getEmergencySurveyStakingSourceLocationId : ROBE id getMinimumBlockNumberFunctionalityAddress : Address of the Functionality that controls the block duration of regular proposals getMinimumBlockNumberSourceLocationId : ROBE id sourceLocation : ROBE location of the source code isAuthorizedFunctionality(address) Check that the Functionality is an authorized one Params functionality : Functionality to be checked Returns success : Boolean flag indicating the authorization status of the Functionality isValidFunctionality(address) Check that the Functionality is a valid one Params functionality : Functionality to be checked Returns valid : Boolean flag indicating the validity of the Functionality removeFunctionality(string) Remove a Functionality from the Functionalities Manager Params codeName : ID of the Functionality to remove Returns position : Position of the removed functionality removed : Boolean flag representing the success status of the operation setProxy() SET the proxy","title":"IMVDFunctionalitiesManager"},{"location":"contracts/IMVDFunctionalitiesManager/#contract-imvdfunctionalitiesmanager","text":"Path: contracts/IMVDFunctionalitiesManager.sol Version: 1 Title: Interface for the Functionalities Manager None","title":"Contract IMVDFunctionalitiesManager"},{"location":"contracts/IMVDFunctionalitiesManager/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalitiesManager/#addfunctionalitystringaddressuint256addressboolstringstringboolbool","text":"Add a functionality to the Functionalities Manager","title":"addFunctionality(string,address,uint256,address,bool,string,string,bool,bool)"},{"location":"contracts/IMVDFunctionalitiesManager/#params","text":"codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#addfunctionalitystringaddressuint256addressboolstringstringboolbooluint256","text":"Replace a Functionality in the Functionalities Manager","title":"addFunctionality(string,address,uint256,address,bool,string,string,bool,bool,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_1","text":"codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place position : Position of the Functionality to replace returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitynames","text":"GET all Functionalities Names (IDs)","title":"functionalityNames()"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitynamesuint256uint256","text":"GET all Functionalities Names (IDs) in a portion of the array","title":"functionalityNames(uint256,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitytojsonstring","text":"Given a Functionality ID return its JSON encoded version","title":"functionalityToJSON(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#getfunctionalitiesamount","text":"GET the amount of functionalities present in the Functionalities Manager","title":"getFunctionalitiesAmount()"},{"location":"contracts/IMVDFunctionalitiesManager/#getproxy","text":"GET the proxy","title":"getProxy()"},{"location":"contracts/IMVDFunctionalitiesManager/#hasfunctionalitystring","text":"Check that the FunctionalitiesManager has a specific Functionality","title":"hasFunctionality(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_2","text":"codeName : ID of the Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns","text":"output : Boolean flag indicating wether the Functionalities Manager has the given Functionality.","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#initaddressuint256addressuint256addressuint256addressuint256address","text":"Initializer logic used during the constructor call","title":"init(address,uint256,address,uint256,address,uint256,address,uint256,address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_3","text":"checkVoteResultFunctionalityAddress : Address for the Functionality that controls the check for determining if a Proposal was successful or it failed checkVoteResultSourceLocationId : ROBE id getEmergencyMinimumBlockNumberFunctionalityAddress : Address for the Functionality that controls the block duration of emergency proposals getEmergencyMinimumBlockNumberSourceLocationId : ROBE id getEmergencySurveyStakingFunctionalityAddress : Address for the Functionality that controls the minimum amount of vote to be staked in order to start an Emergency Proposal getEmergencySurveyStakingSourceLocationId : ROBE id getMinimumBlockNumberFunctionalityAddress : Address of the Functionality that controls the block duration of regular proposals getMinimumBlockNumberSourceLocationId : ROBE id sourceLocation : ROBE location of the source code","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#isauthorizedfunctionalityaddress","text":"Check that the Functionality is an authorized one","title":"isAuthorizedFunctionality(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_4","text":"functionality : Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_1","text":"success : Boolean flag indicating the authorization status of the Functionality","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#isvalidfunctionalityaddress","text":"Check that the Functionality is a valid one","title":"isValidFunctionality(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_5","text":"functionality : Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_2","text":"valid : Boolean flag indicating the validity of the Functionality","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#removefunctionalitystring","text":"Remove a Functionality from the Functionalities Manager","title":"removeFunctionality(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_6","text":"codeName : ID of the Functionality to remove","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_3","text":"position : Position of the removed functionality removed : Boolean flag representing the success status of the operation","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#setproxy","text":"SET the proxy","title":"setProxy()"},{"location":"contracts/IMVDFunctionalityModelsManager/","text":"Contract IMVDFunctionalityModelsManager Path: contracts/IMVDFunctionalityModelsManager.sol Version: 1 Title: Functionalities Models Manager Well Known Functionalities are \"special\" Fnctionalities must be implemented according to a specific pattern. Well Known Functionalities can be found in the implementation of this Interface. Methods checkWellKnownFunctionalities(string,bool,string,string,bool,bool,string) Check Well Known Functionalities. If the check fails it will raise its own errors. Params codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place replaces : // DOCUMENT returnAbiParametersArray : Array of return values obtained from the called microservice's method submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"IMVDFunctionalityModelsManager"},{"location":"contracts/IMVDFunctionalityModelsManager/#contract-imvdfunctionalitymodelsmanager","text":"Path: contracts/IMVDFunctionalityModelsManager.sol Version: 1 Title: Functionalities Models Manager Well Known Functionalities are \"special\" Fnctionalities must be implemented according to a specific pattern. Well Known Functionalities can be found in the implementation of this Interface.","title":"Contract IMVDFunctionalityModelsManager"},{"location":"contracts/IMVDFunctionalityModelsManager/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalityModelsManager/#checkwellknownfunctionalitiesstringboolstringstringboolboolstring","text":"Check Well Known Functionalities. If the check fails it will raise its own errors.","title":"checkWellKnownFunctionalities(string,bool,string,string,bool,bool,string)"},{"location":"contracts/IMVDFunctionalityModelsManager/#params","text":"codeName : ID of the Functionality isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place replaces : // DOCUMENT returnAbiParametersArray : Array of return values obtained from the called microservice's method submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/","text":"Contract IMVDFunctionalityProposal Path: contracts/IMVDFunctionalityProposal.sol Version: 1 Title: Interface for Proposal Proposals are the defacto heart of the protocol since they allow voting token holders potentially alter all of the logic of a DFO and even extend it via custom logic. Methods accept(uint256) // DOCUMENT disable() // DOCUMENT getCodeName() GET the Proposal Functionality string ID getLocation() GET address of the microservice getMethodSignature() GET the name of the microservice method to invoke getProposer() GET the address of the proposer getProxy() GET the Proxy address getReplaces() // DOCUMENTATION getReturnAbiParametersArray() GET the array of return values obtained from the called microservice's method getSourceLocation() GET the ROBE source location getSourceLocationId() GET the ROBE id getSurveyDuration() GET the duration of the Proposal in number of blocks getSurveyEndBlock() GET The proposal end block getVote(address) GET the current status of the voting Params addr : // DOCUMENT Returns accept : Amount of YES votes refuse : Amount of NO votes getVotes() // DOCUMENT getVotesHardCapToReach() GET the HardCap value init(string,address,string,string,string,address) Functionality Initializer Params codeName : String ID of the Functionality location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call proxy : Address of the proxy replaces : // DOCUMENTATION returnAbiParametersArray : Array of return values obtained from the called microservice's method isDisabled() // DOCUMENT isEmergency() GET the boolean flag indicating wether the Proposal is an Emergency Proposal isInternal() GET the boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) isTerminated() // DOCUMENT isVotesHardCapReached() Check that the HardCap has been reached issubmittable() GET the boolean flag controlling wether the microservice writes data to the chain moveToAccept(uint256) // DOCUMENT moveToRefuse(uint256) // DOCUMENT needsSender() GET the boolean flag controlling wether the original Proxy caller address should be forwarded or not refuse(uint256) // DOCUMENT retireAccept(uint256) // DOCUMENT retireAll() // DOCUMENT retireRefuse(uint256) // DOCUMENT set() // DOCUMENT setCollateralData(bool,address,uint256,bool,bool,bool,address,uint256) set the collateral attributes of the proposal Params emergency : Bool flag controlling wether this is a standard or emergency proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place proposer : Address of the proposer sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain votesHardCap : Hardcap value start() // DOCUMENT terminate() // DOCUMENT toJSON() GET the json representation of the Functionality withdraw() // DOCUMENT","title":"IMVDFunctionalityProposal"},{"location":"contracts/IMVDFunctionalityProposal/#contract-imvdfunctionalityproposal","text":"Path: contracts/IMVDFunctionalityProposal.sol Version: 1 Title: Interface for Proposal Proposals are the defacto heart of the protocol since they allow voting token holders potentially alter all of the logic of a DFO and even extend it via custom logic.","title":"Contract IMVDFunctionalityProposal"},{"location":"contracts/IMVDFunctionalityProposal/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalityProposal/#acceptuint256","text":"// DOCUMENT","title":"accept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#disable","text":"// DOCUMENT","title":"disable()"},{"location":"contracts/IMVDFunctionalityProposal/#getcodename","text":"GET the Proposal Functionality string ID","title":"getCodeName()"},{"location":"contracts/IMVDFunctionalityProposal/#getlocation","text":"GET address of the microservice","title":"getLocation()"},{"location":"contracts/IMVDFunctionalityProposal/#getmethodsignature","text":"GET the name of the microservice method to invoke","title":"getMethodSignature()"},{"location":"contracts/IMVDFunctionalityProposal/#getproposer","text":"GET the address of the proposer","title":"getProposer()"},{"location":"contracts/IMVDFunctionalityProposal/#getproxy","text":"GET the Proxy address","title":"getProxy()"},{"location":"contracts/IMVDFunctionalityProposal/#getreplaces","text":"// DOCUMENTATION","title":"getReplaces()"},{"location":"contracts/IMVDFunctionalityProposal/#getreturnabiparametersarray","text":"GET the array of return values obtained from the called microservice's method","title":"getReturnAbiParametersArray()"},{"location":"contracts/IMVDFunctionalityProposal/#getsourcelocation","text":"GET the ROBE source location","title":"getSourceLocation()"},{"location":"contracts/IMVDFunctionalityProposal/#getsourcelocationid","text":"GET the ROBE id","title":"getSourceLocationId()"},{"location":"contracts/IMVDFunctionalityProposal/#getsurveyduration","text":"GET the duration of the Proposal in number of blocks","title":"getSurveyDuration()"},{"location":"contracts/IMVDFunctionalityProposal/#getsurveyendblock","text":"GET The proposal end block","title":"getSurveyEndBlock()"},{"location":"contracts/IMVDFunctionalityProposal/#getvoteaddress","text":"GET the current status of the voting","title":"getVote(address)"},{"location":"contracts/IMVDFunctionalityProposal/#params","text":"addr : // DOCUMENT","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#returns","text":"accept : Amount of YES votes refuse : Amount of NO votes","title":"Returns"},{"location":"contracts/IMVDFunctionalityProposal/#getvotes","text":"// DOCUMENT","title":"getVotes()"},{"location":"contracts/IMVDFunctionalityProposal/#getvoteshardcaptoreach","text":"GET the HardCap value","title":"getVotesHardCapToReach()"},{"location":"contracts/IMVDFunctionalityProposal/#initstringaddressstringstringstringaddress","text":"Functionality Initializer","title":"init(string,address,string,string,string,address)"},{"location":"contracts/IMVDFunctionalityProposal/#params_1","text":"codeName : String ID of the Functionality location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call proxy : Address of the proxy replaces : // DOCUMENTATION returnAbiParametersArray : Array of return values obtained from the called microservice's method","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#isdisabled","text":"// DOCUMENT","title":"isDisabled()"},{"location":"contracts/IMVDFunctionalityProposal/#isemergency","text":"GET the boolean flag indicating wether the Proposal is an Emergency Proposal","title":"isEmergency()"},{"location":"contracts/IMVDFunctionalityProposal/#isinternal","text":"GET the boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true)","title":"isInternal()"},{"location":"contracts/IMVDFunctionalityProposal/#isterminated","text":"// DOCUMENT","title":"isTerminated()"},{"location":"contracts/IMVDFunctionalityProposal/#isvoteshardcapreached","text":"Check that the HardCap has been reached","title":"isVotesHardCapReached()"},{"location":"contracts/IMVDFunctionalityProposal/#issubmittable","text":"GET the boolean flag controlling wether the microservice writes data to the chain","title":"issubmittable()"},{"location":"contracts/IMVDFunctionalityProposal/#movetoacceptuint256","text":"// DOCUMENT","title":"moveToAccept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#movetorefuseuint256","text":"// DOCUMENT","title":"moveToRefuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#needssender","text":"GET the boolean flag controlling wether the original Proxy caller address should be forwarded or not","title":"needsSender()"},{"location":"contracts/IMVDFunctionalityProposal/#refuseuint256","text":"// DOCUMENT","title":"refuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#retireacceptuint256","text":"// DOCUMENT","title":"retireAccept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#retireall","text":"// DOCUMENT","title":"retireAll()"},{"location":"contracts/IMVDFunctionalityProposal/#retirerefuseuint256","text":"// DOCUMENT","title":"retireRefuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#set","text":"// DOCUMENT","title":"set()"},{"location":"contracts/IMVDFunctionalityProposal/#setcollateraldatabooladdressuint256boolboolbooladdressuint256","text":"set the collateral attributes of the proposal","title":"setCollateralData(bool,address,uint256,bool,bool,bool,address,uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#params_2","text":"emergency : Bool flag controlling wether this is a standard or emergency proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place proposer : Address of the proposer sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain votesHardCap : Hardcap value","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#start","text":"// DOCUMENT","title":"start()"},{"location":"contracts/IMVDFunctionalityProposal/#terminate","text":"// DOCUMENT","title":"terminate()"},{"location":"contracts/IMVDFunctionalityProposal/#tojson","text":"GET the json representation of the Functionality","title":"toJSON()"},{"location":"contracts/IMVDFunctionalityProposal/#withdraw","text":"// DOCUMENT","title":"withdraw()"},{"location":"contracts/IMVDProxy/","text":"Contract IMVDProxy Path: contracts/IMVDProxy.sol Version: 1 Title: Proxy Interface None Methods getDoubleProxyAddress() GET the Double Proxy contract address getMVDFunctionalitiesManagerAddress() GET the Functionalities Manager contract address getMVDFunctionalityModelsManagerAddress() GET the Functionality Models Manager contract address getMVDFunctionalityProposalManagerAddress() GET the Functionality Proposal Manager contract address getMVDWalletAddress() GET the Wallet contract address getStateHolderAddress() GET the State Holder contract address getToken() GET the voting token contract address init(address,address,address,address,address,address,address) Initialization logic used during the constructor call Params doubleProxyAddress : Address of the double proxy functionalitiesManagerAddress : Address of the Functionalities Manager functionalityModelsManagerAddress : Address of the Functionality Models Manager functionalityProposalManagerAddress : Address of the Functionality Proposal Manager stateHolderAddress : Address of the State Holder contract votingTokenAddress : Address of the Voting Token walletAddress : Address of the wallet newProposal(string,bool,address,uint256,address,bool,string,string,bool,bool,string) Add a new proposal Params codeName : ID of the Proposal emergency : Boolean, true -> Emergency Proposal, false -> Standard Proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can replaces : // DOCUMENT returnParametersJSONArray : Array of json encoded return parameters of the proposal sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain Returns proposalAddress : Address of the newly created proposal transfer(address,uint256,address) Transfer a token to an address Params receiver : Address of the receiver token : Address of the token to transfer value : Amount of token to transfer transfer721(address,uint256,bytes,bool,address) Transfer an ERC721 to an address Params data : // DOCUMENTATION receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"IMVDProxy"},{"location":"contracts/IMVDProxy/#contract-imvdproxy","text":"Path: contracts/IMVDProxy.sol Version: 1 Title: Proxy Interface None","title":"Contract IMVDProxy"},{"location":"contracts/IMVDProxy/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDProxy/#getdoubleproxyaddress","text":"GET the Double Proxy contract address","title":"getDoubleProxyAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalitiesmanageraddress","text":"GET the Functionalities Manager contract address","title":"getMVDFunctionalitiesManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalitymodelsmanageraddress","text":"GET the Functionality Models Manager contract address","title":"getMVDFunctionalityModelsManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalityproposalmanageraddress","text":"GET the Functionality Proposal Manager contract address","title":"getMVDFunctionalityProposalManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdwalletaddress","text":"GET the Wallet contract address","title":"getMVDWalletAddress()"},{"location":"contracts/IMVDProxy/#getstateholderaddress","text":"GET the State Holder contract address","title":"getStateHolderAddress()"},{"location":"contracts/IMVDProxy/#gettoken","text":"GET the voting token contract address","title":"getToken()"},{"location":"contracts/IMVDProxy/#initaddressaddressaddressaddressaddressaddressaddress","text":"Initialization logic used during the constructor call","title":"init(address,address,address,address,address,address,address)"},{"location":"contracts/IMVDProxy/#params","text":"doubleProxyAddress : Address of the double proxy functionalitiesManagerAddress : Address of the Functionalities Manager functionalityModelsManagerAddress : Address of the Functionality Models Manager functionalityProposalManagerAddress : Address of the Functionality Proposal Manager stateHolderAddress : Address of the State Holder contract votingTokenAddress : Address of the Voting Token walletAddress : Address of the wallet","title":"Params"},{"location":"contracts/IMVDProxy/#newproposalstringbooladdressuint256addressboolstringstringboolboolstring","text":"Add a new proposal","title":"newProposal(string,bool,address,uint256,address,bool,string,string,bool,bool,string)"},{"location":"contracts/IMVDProxy/#params_1","text":"codeName : ID of the Proposal emergency : Boolean, true -> Emergency Proposal, false -> Standard Proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can replaces : // DOCUMENT returnParametersJSONArray : Array of json encoded return parameters of the proposal sourceLocation : ROBE location of the source code sourceLocationId : ROBE id submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDProxy/#returns","text":"proposalAddress : Address of the newly created proposal","title":"Returns"},{"location":"contracts/IMVDProxy/#transferaddressuint256address","text":"Transfer a token to an address","title":"transfer(address,uint256,address)"},{"location":"contracts/IMVDProxy/#params_2","text":"receiver : Address of the receiver token : Address of the token to transfer value : Amount of token to transfer","title":"Params"},{"location":"contracts/IMVDProxy/#transfer721addressuint256bytesbooladdress","text":"Transfer an ERC721 to an address","title":"transfer721(address,uint256,bytes,bool,address)"},{"location":"contracts/IMVDProxy/#params_3","text":"data : // DOCUMENTATION receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IMVDWallet/","text":"Contract IMVDWallet Path: contracts/IMVDWallet.sol Version: 1 Title: Wallet // DOCUMENTATION Methods flush721ToNewWallet(uint256,bytes,bool,address) Transfer an ERC721 to the NewWallet Params data : // DOCUMENTATION safe : Boolean flag for triggering the SafeTransfer tokenAddress : Address of the token to transfer tokenId : ID of the ERC721 to transfer flushToNewWallet(address) Send all of the specified tokens to the NewWallet Params token : Address of the token to send getProxy() GET the proxy address setNewWallet(address,address) SET new wallet Params newWallet : New wallet address tokenAddress : // DOCUMENT setProxy() SET the proxy address transfer(address,uint256,address) Transfer a token to an address Params receiver : Address of the receiver tokenAddress : Address of the token to transfer value : Amount of token to transfer transfer(address,uint256,bytes,bool,address) Transfer an ERC721 to an address Params data : // DOCUMENTATION receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"IMVDWallet"},{"location":"contracts/IMVDWallet/#contract-imvdwallet","text":"Path: contracts/IMVDWallet.sol Version: 1 Title: Wallet // DOCUMENTATION","title":"Contract IMVDWallet"},{"location":"contracts/IMVDWallet/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDWallet/#flush721tonewwalletuint256bytesbooladdress","text":"Transfer an ERC721 to the NewWallet","title":"flush721ToNewWallet(uint256,bytes,bool,address)"},{"location":"contracts/IMVDWallet/#params","text":"data : // DOCUMENTATION safe : Boolean flag for triggering the SafeTransfer tokenAddress : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IMVDWallet/#flushtonewwalletaddress","text":"Send all of the specified tokens to the NewWallet","title":"flushToNewWallet(address)"},{"location":"contracts/IMVDWallet/#params_1","text":"token : Address of the token to send","title":"Params"},{"location":"contracts/IMVDWallet/#getproxy","text":"GET the proxy address","title":"getProxy()"},{"location":"contracts/IMVDWallet/#setnewwalletaddressaddress","text":"SET new wallet","title":"setNewWallet(address,address)"},{"location":"contracts/IMVDWallet/#params_2","text":"newWallet : New wallet address tokenAddress : // DOCUMENT","title":"Params"},{"location":"contracts/IMVDWallet/#setproxy","text":"SET the proxy address","title":"setProxy()"},{"location":"contracts/IMVDWallet/#transferaddressuint256address","text":"Transfer a token to an address","title":"transfer(address,uint256,address)"},{"location":"contracts/IMVDWallet/#params_3","text":"receiver : Address of the receiver tokenAddress : Address of the token to transfer value : Amount of token to transfer","title":"Params"},{"location":"contracts/IMVDWallet/#transferaddressuint256bytesbooladdress","text":"Transfer an ERC721 to an address","title":"transfer(address,uint256,bytes,bool,address)"},{"location":"contracts/IMVDWallet/#params_4","text":"data : // DOCUMENTATION receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IVotingToken/","text":"Contract IVotingToken Path: contracts/IVotingToken.sol Version: 1 Title: Voting Token interface None Methods burn(uint256) Burn functionality of the voting token decimals() GET amount of decimals supported by the token getProxy() GET the Proxy init(string,string,uint256,uint256) Initialization logic using during the constructor Call Params decimals : Amount of decimals supported by the token name : Name of the token used symbol : Ticker symbol of the token used totalSupply : Total Supply of the token mint(uint256) Mint functionality of the voting token name() GET the token name setProxy() SET the Proxy symbol() GET the token ticker symbol","title":"IVotingToken"},{"location":"contracts/IVotingToken/#contract-ivotingtoken","text":"Path: contracts/IVotingToken.sol Version: 1 Title: Voting Token interface None","title":"Contract IVotingToken"},{"location":"contracts/IVotingToken/#methods","text":"","title":"Methods"},{"location":"contracts/IVotingToken/#burnuint256","text":"Burn functionality of the voting token","title":"burn(uint256)"},{"location":"contracts/IVotingToken/#decimals","text":"GET amount of decimals supported by the token","title":"decimals()"},{"location":"contracts/IVotingToken/#getproxy","text":"GET the Proxy","title":"getProxy()"},{"location":"contracts/IVotingToken/#initstringstringuint256uint256","text":"Initialization logic using during the constructor Call","title":"init(string,string,uint256,uint256)"},{"location":"contracts/IVotingToken/#params","text":"decimals : Amount of decimals supported by the token name : Name of the token used symbol : Ticker symbol of the token used totalSupply : Total Supply of the token","title":"Params"},{"location":"contracts/IVotingToken/#mintuint256","text":"Mint functionality of the voting token","title":"mint(uint256)"},{"location":"contracts/IVotingToken/#name","text":"GET the token name","title":"name()"},{"location":"contracts/IVotingToken/#setproxy","text":"SET the Proxy","title":"setProxy()"},{"location":"contracts/IVotingToken/#symbol","text":"GET the token ticker symbol","title":"symbol()"}]}