{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Decentralized Flexible Organization - DFO Microservices on Ethereum \ud83d\udc7d for Independent Dapps ugradable by voting \ud83d\ude31 Authors: Marco Vasapollo ( @vasapower ) and Alessandro Mario Lagan\u00e0 Toschi ( @alessandromlt ) | bro@buidl.life Join us: https://www.notion.so/Community-Guidelines-a03ceeab28254eb3944ab85320be70de The Basis DFO is a new concept that reshapes the way to build Decentralized Applications (DApps), enabling the creation of extendible, improvable and fixable Systems , using an approach called Smart Contract as Microservice which avoids the slow and dangerous monolythic Smart Contract development procedures. Because of everything is completely deployed and running on the Ethereum blockchain , the need of Centralized or Distributed Servers is finally bypassed. In DFO, every DApp functionality is a Smart Contract acting like a Microservice , which can also be stateless and therefore reusable in different applications. Instead of directly using Smart Contracts functions, calling their specific address, in DFO you will interact with the Proxy which will keep track of the latest correct versions of all Microservices (located in different addresses) composing your DApp. No matter how many Microservices will you attach, detach or replace to a DFO since its creation. The address of your Dapp will be always the same, forever . DFO is completely Community Driven . This means that every strategic decision about the DApp Functionalities and their future is taken by its Token Holders. In fact, to add/replace/remove a Microservice, the proposer must interact with the Proxy to start a Survey which can be voted by the ones holding the ERC20 Voting Tokens linked to that DFO, staking them to accept or refuse the proposal. The governance rules (that establish the success or the failure of a Survey) are, in turn, Functionalities of the DFO itself located within Microservices that can be updated too... through Proposals! The Proxy, the Voting Token, the Proposals, the Governance Rules and some other Smart Contracts are all the components that make up every single DFO. Every DFO is a bunch of Smart Contracts cooperating each other to let users: using Functionalities in both Read and Write Mode; proposing to add/remove/replace these Functionalities through Surveys; voting to Accept/Refuse them through Voting Tokens. Even the Smart Contracts of a DFO can be updated to address bug fixes or to expand the potential of the protocol just making a Proposal to the Token Holders Community. To let people create and use DFOs, we built DFOHub , our R&D community-driven project that aims to improve the DFO protocol itself by managing its progress through a DFO maintained by its own token holders, who can propose or vote for improvements and bug fixes with anonymous, decentralized and very easy steps. DFOHub extremely facilitates the deployment processes for a new DFO, you can exploit it in two ways: using the easy steps of the wizard we coded on DFOHub ; [ COMING SOON ] using the integration SDK which lets you easily integrate DFO protocol capabilities in your DApp.","title":"Home"},{"location":"#decentralized-flexible-organization-dfo","text":"","title":"Decentralized Flexible Organization - DFO"},{"location":"#microservices-on-ethereum-for-independent-dapps-ugradable-by-voting","text":"","title":"Microservices on Ethereum \ud83d\udc7d for Independent Dapps ugradable by voting  \ud83d\ude31"},{"location":"#authors-marco-vasapollo-vasapower-and-alessandro-mario-lagana-toschi-alessandromlt-amp98amp114amp111amp64amp98amp117amp105amp100amp108amp46amp108amp105amp102amp101","text":"","title":"Authors: Marco Vasapollo (@vasapower) and Alessandro Mario Lagan\u00e0 Toschi (@alessandromlt) | \u0002amp\u0003#98;\u0002amp\u0003#114;\u0002amp\u0003#111;\u0002amp\u0003#64;\u0002amp\u0003#98;\u0002amp\u0003#117;\u0002amp\u0003#105;\u0002amp\u0003#100;\u0002amp\u0003#108;\u0002amp\u0003#46;\u0002amp\u0003#108;\u0002amp\u0003#105;\u0002amp\u0003#102;\u0002amp\u0003#101;"},{"location":"#join-us-httpswwwnotionsocommunity-guidelines-a03ceeab28254eb3944ab85320be70de","text":"","title":"Join us: https://www.notion.so/Community-Guidelines-a03ceeab28254eb3944ab85320be70de"},{"location":"#the-basis","text":"DFO is a new concept that reshapes the way to build Decentralized Applications (DApps), enabling the creation of extendible, improvable and fixable Systems , using an approach called Smart Contract as Microservice which avoids the slow and dangerous monolythic Smart Contract development procedures. Because of everything is completely deployed and running on the Ethereum blockchain , the need of Centralized or Distributed Servers is finally bypassed. In DFO, every DApp functionality is a Smart Contract acting like a Microservice , which can also be stateless and therefore reusable in different applications. Instead of directly using Smart Contracts functions, calling their specific address, in DFO you will interact with the Proxy which will keep track of the latest correct versions of all Microservices (located in different addresses) composing your DApp. No matter how many Microservices will you attach, detach or replace to a DFO since its creation. The address of your Dapp will be always the same, forever . DFO is completely Community Driven . This means that every strategic decision about the DApp Functionalities and their future is taken by its Token Holders. In fact, to add/replace/remove a Microservice, the proposer must interact with the Proxy to start a Survey which can be voted by the ones holding the ERC20 Voting Tokens linked to that DFO, staking them to accept or refuse the proposal. The governance rules (that establish the success or the failure of a Survey) are, in turn, Functionalities of the DFO itself located within Microservices that can be updated too... through Proposals! The Proxy, the Voting Token, the Proposals, the Governance Rules and some other Smart Contracts are all the components that make up every single DFO. Every DFO is a bunch of Smart Contracts cooperating each other to let users: using Functionalities in both Read and Write Mode; proposing to add/remove/replace these Functionalities through Surveys; voting to Accept/Refuse them through Voting Tokens. Even the Smart Contracts of a DFO can be updated to address bug fixes or to expand the potential of the protocol just making a Proposal to the Token Holders Community. To let people create and use DFOs, we built DFOHub , our R&D community-driven project that aims to improve the DFO protocol itself by managing its progress through a DFO maintained by its own token holders, who can propose or vote for improvements and bug fixes with anonymous, decentralized and very easy steps. DFOHub extremely facilitates the deployment processes for a new DFO, you can exploit it in two ways: using the easy steps of the wizard we coded on DFOHub ; [ COMING SOON ] using the integration SDK which lets you easily integrate DFO protocol capabilities in your DApp.","title":"The Basis"},{"location":"CONTRIBUTING/","text":"Contributing guidelines Table of Contents Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs Coding Style Solidity Solidity portions of the codebase adhere follow the official Solidity Styleguide JavaScript Python Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings. Documentation New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve mkdocs To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"","title":"Contributing guidelines"},{"location":"CONTRIBUTING/#table-of-contents","text":"Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs","title":"Table of Contents"},{"location":"CONTRIBUTING/#coding-style","text":"","title":"Coding Style"},{"location":"CONTRIBUTING/#solidity","text":"Solidity portions of the codebase adhere follow the official Solidity Styleguide","title":"Solidity"},{"location":"CONTRIBUTING/#javascript","text":"","title":"JavaScript"},{"location":"CONTRIBUTING/#python","text":"Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings.","title":"Python"},{"location":"CONTRIBUTING/#documentation","text":"New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve","title":"Documentation"},{"location":"CONTRIBUTING/#mkdocs","text":"To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"mkdocs"},{"location":"contracts/ICommonUtilities/","text":"Contract ICommonUtilities Path: contracts/ICommonUtilities.sol Version: 1 Title: Common Utilities Collection of simple utilities Methods compareStrings(string,string) Compare to strings toAddress(bytes) Convert bytes address to address toLowerCase(string) Convert a string to lowercase toString(address) Convert address to string toString(uint256) Convert uint to string toUint256(bytes) Convert bytes address to uint","title":"ICommonUtilities"},{"location":"contracts/ICommonUtilities/#contract-icommonutilities","text":"Path: contracts/ICommonUtilities.sol Version: 1 Title: Common Utilities Collection of simple utilities","title":"Contract ICommonUtilities"},{"location":"contracts/ICommonUtilities/#methods","text":"","title":"Methods"},{"location":"contracts/ICommonUtilities/#comparestringsstringstring","text":"Compare to strings","title":"compareStrings(string,string)"},{"location":"contracts/ICommonUtilities/#toaddressbytes","text":"Convert bytes address to address","title":"toAddress(bytes)"},{"location":"contracts/ICommonUtilities/#tolowercasestring","text":"Convert a string to lowercase","title":"toLowerCase(string)"},{"location":"contracts/ICommonUtilities/#tostringaddress","text":"Convert address to string","title":"toString(address)"},{"location":"contracts/ICommonUtilities/#tostringuint256","text":"Convert uint to string","title":"toString(uint256)"},{"location":"contracts/ICommonUtilities/#touint256bytes","text":"Convert bytes address to uint","title":"toUint256(bytes)"},{"location":"contracts/IDoubleProxy/","text":"Contract IDoubleProxy Path: contracts/IDoubleProxy.sol Version: 1 Title: Double Proxy Interface Double Proxy is the easiest way for side/external Contracts to locate and query the DFO. As the main Core Contract of a DFO is the Proxy, it also can be updated by Proposals. So, directly link the Proxy to external Contracts can be really a problem. To avoid this, it is better to link external contracts with the DoubleProxy. DoubleProxy is the Proxy of the Proxy, and is a Delegate that keeps track of the most recent Proxy address and all the other previous Proxies. Because it has a very lightweight and simple structure and logic, it does not need of changes, so it can be used as a secure anchor. Methods init(address[],address) Initializer logic used during the constructor call Params currentProxy : Address of the current Proxy proxies : Array of address of the old proxies, only used in legacy scenarios. Can be left empty. isProxy(address) Check if the address is or has been a Proxy proxies() Retrieve all the proxies proxies(uint256,uint256) Retrieve a portion of the proxies Params offset : End Position start : Start Position proxiesLength() GET the number of proxies proxy() GET the current Proxy setProxy() Method callable by the current Proxy only. It is used when the Proxy or this delegate changes.","title":"IDounleProxy"},{"location":"contracts/IDoubleProxy/#contract-idoubleproxy","text":"Path: contracts/IDoubleProxy.sol Version: 1 Title: Double Proxy Interface Double Proxy is the easiest way for side/external Contracts to locate and query the DFO. As the main Core Contract of a DFO is the Proxy, it also can be updated by Proposals. So, directly link the Proxy to external Contracts can be really a problem. To avoid this, it is better to link external contracts with the DoubleProxy. DoubleProxy is the Proxy of the Proxy, and is a Delegate that keeps track of the most recent Proxy address and all the other previous Proxies. Because it has a very lightweight and simple structure and logic, it does not need of changes, so it can be used as a secure anchor.","title":"Contract IDoubleProxy"},{"location":"contracts/IDoubleProxy/#methods","text":"","title":"Methods"},{"location":"contracts/IDoubleProxy/#initaddressaddress","text":"Initializer logic used during the constructor call","title":"init(address[],address)"},{"location":"contracts/IDoubleProxy/#params","text":"currentProxy : Address of the current Proxy proxies : Array of address of the old proxies, only used in legacy scenarios. Can be left empty.","title":"Params"},{"location":"contracts/IDoubleProxy/#isproxyaddress","text":"Check if the address is or has been a Proxy","title":"isProxy(address)"},{"location":"contracts/IDoubleProxy/#proxies","text":"Retrieve all the proxies","title":"proxies()"},{"location":"contracts/IDoubleProxy/#proxiesuint256uint256","text":"Retrieve a portion of the proxies","title":"proxies(uint256,uint256)"},{"location":"contracts/IDoubleProxy/#params_1","text":"offset : End Position start : Start Position","title":"Params"},{"location":"contracts/IDoubleProxy/#proxieslength","text":"GET the number of proxies","title":"proxiesLength()"},{"location":"contracts/IDoubleProxy/#proxy","text":"GET the current Proxy","title":"proxy()"},{"location":"contracts/IDoubleProxy/#setproxy","text":"Method callable by the current Proxy only. It is used when the Proxy or this delegate changes.","title":"setProxy()"},{"location":"contracts/IMVDFunctionalitiesManager/","text":"Contract IMVDFunctionalitiesManager Path: contracts/IMVDFunctionalitiesManager.sol Version: 1 Title: Interface for the Functionalities Manager Functionalities Manager is the one that keeps track of all the Microservices of a DFO. It also contains all the logic to set/unset Microservices after a Proposal. Methods addFunctionality(string,address,uint256,address,bool,string,string,bool,bool) Add a functionality to the Functionalities Manager Params codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made by the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain addFunctionality(string,address,uint256,address,bool,string,string,bool,bool,uint256) Replace a Functionality in the Functionalities Manager Params codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place position : Position of the Functionality to replace returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain clearCallingContext() This method can be called only by the Proxy. Clears the context at the end of the Microservice execution functionalitiesToJSON() For frontend purposes. Gives back the info about functionalities using the JSON Array format functionalitiesToJSON(uint256,uint256) For frontend purposes. Gives back the info about functionalities using the JSON Array format Params l : the array offset start : the start position of the array functionalityNames() GET all Functionalities Names (IDs) functionalityNames(uint256,uint256) GET all Functionalities Names (IDs) in a portion of the array functionalityToJSON(string) Given a Functionality ID return its JSON encoded version getFunctionalitiesAmount() GET the amount of functionalities present in the Functionalities Manager getFunctionalityData(string) Utility method to retrieve all important stuff to call a Microservice Params codeName : the codeName of the Microservice you need info Returns _0 : the address of the contract including the logic of the Microservice, the method signature of the Microservice, the position in the Functionalities array, the location of the source code, saved in byte64 concatenated data chunks, the locationId of the source code. getProxy() GET the Proxy hasFunctionality(string) Check that the FunctionalitiesManager has a specific Functionality Params codeName : ID of the Functionality to be checked Returns output : Boolean flag indicating wether the Functionalities Manager has the given Functionality. init(address,uint256,address,uint256,address,uint256,address,uint256,address) Initializer logic used during the constructor call Params checkVoteResultFunctionalityAddress : Address for the Functionality that controls the check for determining if a Proposal was successful or it failed checkVoteResultSourceLocationId : Base64 data chunk id of the corresponding Microservice getEmergencyMinimumBlockNumberFunctionalityAddress : Address for the Functionality that controls the block duration of emergency proposals getEmergencyMinimumBlockNumberSourceLocationId : Base64 data chunk id of the corresponding Microservice getEmergencySurveyStakingFunctionalityAddress : Address for the Functionality that controls the minimum amount of vote to be staked in order to start an Emergency Proposal getEmergencySurveyStakingSourceLocationId : Base64 data chunk id of the corresponding Microservice getMinimumBlockNumberFunctionalityAddress : Address of the Functionality that controls the block duration of regular proposals getMinimumBlockNumberSourceLocationId : Base64 data chunk id of the corresponding Microservice sourceLocation : Location of the source code, saved in concatenated Base64 data chunks isAuthorizedFunctionality(address) Check that the Functionality is an authorized one Params functionality : Functionality to be checked Returns success : Boolean flag indicating the authorization status of the Functionality isValidFunctionality(address) Check that the Functionality is a valid one Params functionality : Functionality to be checked Returns valid : Boolean flag indicating the validity of the Functionality preConditionCheck(string,bytes,uint8,address,uint256) Method called by the Proxy when someone calls a Microservice. It has a double function: checks if you are in the correct context (e.g. are you trying to call a non-submitable Microservice through the correct \"read\" function of the Proxy?) and gives back the address of the Microservice and the correct payload that the proxy will use to execute a .call() method. Params codeName : the Microservice to be called data : the payload to be used within the Microservice (ABI encoded) sender : the original msg.sender of the Proxy read/submit call, to be used if the Microservice has the needsSender flag set to true submittable : 1 true, 0 false value : the original msg.value of the Proxy submit call, to be used if the Microservice is submitable and has the needsSender flag set to true removeFunctionality(string) Remove a Functionality from the Functionalities Manager Params codeName : ID of the Functionality to remove Returns position : Position of the removed functionality removed : Boolean flag representing the success status of the operation setCallingContext(address) This method can be called only by the Proxy. When a new submitable Microservice is called, this method is used to let other DFO Delegates (e.g. StateHolder) to be fully operative. If you call a Microservice directly, bypassing the Proxy, the context will be blank and Delegates cannot allow you to do any operation. Params location : The address of the currently running Microservice Returns changed : True if the calling context is correctly set, false if the context was already set (this happens, for example, when someone calls a Microservice including a logic to call another Microservice through the Proxy). setProxy() SET the Proxy setupFunctionality(address) callable by the Proxy only. Sets up the new Microservice add/replace/remove action, grabbing the data from the MVDFunctionalityProposal at the given address Params proposalAddress : the address of the Proposal to be set","title":"IMVDFunctionalitiesManager"},{"location":"contracts/IMVDFunctionalitiesManager/#contract-imvdfunctionalitiesmanager","text":"Path: contracts/IMVDFunctionalitiesManager.sol Version: 1 Title: Interface for the Functionalities Manager Functionalities Manager is the one that keeps track of all the Microservices of a DFO. It also contains all the logic to set/unset Microservices after a Proposal.","title":"Contract IMVDFunctionalitiesManager"},{"location":"contracts/IMVDFunctionalitiesManager/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalitiesManager/#addfunctionalitystringaddressuint256addressboolstringstringboolbool","text":"Add a functionality to the Functionalities Manager","title":"addFunctionality(string,address,uint256,address,bool,string,string,bool,bool)"},{"location":"contracts/IMVDFunctionalitiesManager/#params","text":"codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made by the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#addfunctionalitystringaddressuint256addressboolstringstringboolbooluint256","text":"Replace a Functionality in the Functionalities Manager","title":"addFunctionality(string,address,uint256,address,bool,string,string,bool,bool,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_1","text":"codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place position : Position of the Functionality to replace returnAbiParametersArray : Array of return values obtained from the called microservice's method sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#clearcallingcontext","text":"This method can be called only by the Proxy. Clears the context at the end of the Microservice execution","title":"clearCallingContext()"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitiestojson","text":"For frontend purposes. Gives back the info about functionalities using the JSON Array format","title":"functionalitiesToJSON()"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitiestojsonuint256uint256","text":"For frontend purposes. Gives back the info about functionalities using the JSON Array format","title":"functionalitiesToJSON(uint256,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_2","text":"l : the array offset start : the start position of the array","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitynames","text":"GET all Functionalities Names (IDs)","title":"functionalityNames()"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitynamesuint256uint256","text":"GET all Functionalities Names (IDs) in a portion of the array","title":"functionalityNames(uint256,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#functionalitytojsonstring","text":"Given a Functionality ID return its JSON encoded version","title":"functionalityToJSON(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#getfunctionalitiesamount","text":"GET the amount of functionalities present in the Functionalities Manager","title":"getFunctionalitiesAmount()"},{"location":"contracts/IMVDFunctionalitiesManager/#getfunctionalitydatastring","text":"Utility method to retrieve all important stuff to call a Microservice","title":"getFunctionalityData(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_3","text":"codeName : the codeName of the Microservice you need info","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns","text":"_0 : the address of the contract including the logic of the Microservice, the method signature of the Microservice, the position in the Functionalities array, the location of the source code, saved in byte64 concatenated data chunks, the locationId of the source code.","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#getproxy","text":"GET the Proxy","title":"getProxy()"},{"location":"contracts/IMVDFunctionalitiesManager/#hasfunctionalitystring","text":"Check that the FunctionalitiesManager has a specific Functionality","title":"hasFunctionality(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_4","text":"codeName : ID of the Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_1","text":"output : Boolean flag indicating wether the Functionalities Manager has the given Functionality.","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#initaddressuint256addressuint256addressuint256addressuint256address","text":"Initializer logic used during the constructor call","title":"init(address,uint256,address,uint256,address,uint256,address,uint256,address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_5","text":"checkVoteResultFunctionalityAddress : Address for the Functionality that controls the check for determining if a Proposal was successful or it failed checkVoteResultSourceLocationId : Base64 data chunk id of the corresponding Microservice getEmergencyMinimumBlockNumberFunctionalityAddress : Address for the Functionality that controls the block duration of emergency proposals getEmergencyMinimumBlockNumberSourceLocationId : Base64 data chunk id of the corresponding Microservice getEmergencySurveyStakingFunctionalityAddress : Address for the Functionality that controls the minimum amount of vote to be staked in order to start an Emergency Proposal getEmergencySurveyStakingSourceLocationId : Base64 data chunk id of the corresponding Microservice getMinimumBlockNumberFunctionalityAddress : Address of the Functionality that controls the block duration of regular proposals getMinimumBlockNumberSourceLocationId : Base64 data chunk id of the corresponding Microservice sourceLocation : Location of the source code, saved in concatenated Base64 data chunks","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#isauthorizedfunctionalityaddress","text":"Check that the Functionality is an authorized one","title":"isAuthorizedFunctionality(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_6","text":"functionality : Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_2","text":"success : Boolean flag indicating the authorization status of the Functionality","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#isvalidfunctionalityaddress","text":"Check that the Functionality is a valid one","title":"isValidFunctionality(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_7","text":"functionality : Functionality to be checked","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_3","text":"valid : Boolean flag indicating the validity of the Functionality","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#preconditioncheckstringbytesuint8addressuint256","text":"Method called by the Proxy when someone calls a Microservice. It has a double function: checks if you are in the correct context (e.g. are you trying to call a non-submitable Microservice through the correct \"read\" function of the Proxy?) and gives back the address of the Microservice and the correct payload that the proxy will use to execute a .call() method.","title":"preConditionCheck(string,bytes,uint8,address,uint256)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_8","text":"codeName : the Microservice to be called data : the payload to be used within the Microservice (ABI encoded) sender : the original msg.sender of the Proxy read/submit call, to be used if the Microservice has the needsSender flag set to true submittable : 1 true, 0 false value : the original msg.value of the Proxy submit call, to be used if the Microservice is submitable and has the needsSender flag set to true","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#removefunctionalitystring","text":"Remove a Functionality from the Functionalities Manager","title":"removeFunctionality(string)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_9","text":"codeName : ID of the Functionality to remove","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_4","text":"position : Position of the removed functionality removed : Boolean flag representing the success status of the operation","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#setcallingcontextaddress","text":"This method can be called only by the Proxy. When a new submitable Microservice is called, this method is used to let other DFO Delegates (e.g. StateHolder) to be fully operative. If you call a Microservice directly, bypassing the Proxy, the context will be blank and Delegates cannot allow you to do any operation.","title":"setCallingContext(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_10","text":"location : The address of the currently running Microservice","title":"Params"},{"location":"contracts/IMVDFunctionalitiesManager/#returns_5","text":"changed : True if the calling context is correctly set, false if the context was already set (this happens, for example, when someone calls a Microservice including a logic to call another Microservice through the Proxy).","title":"Returns"},{"location":"contracts/IMVDFunctionalitiesManager/#setproxy","text":"SET the Proxy","title":"setProxy()"},{"location":"contracts/IMVDFunctionalitiesManager/#setupfunctionalityaddress","text":"callable by the Proxy only. Sets up the new Microservice add/replace/remove action, grabbing the data from the MVDFunctionalityProposal at the given address","title":"setupFunctionality(address)"},{"location":"contracts/IMVDFunctionalitiesManager/#params_11","text":"proposalAddress : the address of the Proposal to be set","title":"Params"},{"location":"contracts/IMVDFunctionalityModelsManager/","text":"Contract IMVDFunctionalityModelsManager Path: contracts/IMVDFunctionalityModelsManager.sol Version: 1 Title: Functionalities Models Manager Well Known Functionalities are \"special\" Functionalities/Microservices must be implemented according to a specific pattern. Well Known Functionalities can be found in the implementation of this Interface. Methods checkWellKnownFunctionalities(string,bool,string,string,bool,bool,string) Check Well Known Functionalities. If the check fails it will raise its own errors. Params codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place replaces : codeName of the microservice that will be replaced by the Proposal to be created, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"IMVDFunctionalityModelsManager"},{"location":"contracts/IMVDFunctionalityModelsManager/#contract-imvdfunctionalitymodelsmanager","text":"Path: contracts/IMVDFunctionalityModelsManager.sol Version: 1 Title: Functionalities Models Manager Well Known Functionalities are \"special\" Functionalities/Microservices must be implemented according to a specific pattern. Well Known Functionalities can be found in the implementation of this Interface.","title":"Contract IMVDFunctionalityModelsManager"},{"location":"contracts/IMVDFunctionalityModelsManager/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalityModelsManager/#checkwellknownfunctionalitiesstringboolstringstringboolboolstring","text":"Check Well Known Functionalities. If the check fails it will raise its own errors.","title":"checkWellKnownFunctionalities(string,bool,string,string,bool,bool,string)"},{"location":"contracts/IMVDFunctionalityModelsManager/#params","text":"codeName : ID of the microservice, to be called by the user through Proxy. isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place replaces : codeName of the microservice that will be replaced by the Proposal to be created, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/","text":"Contract IMVDFunctionalityProposal Path: contracts/IMVDFunctionalityProposal.sol Version: 1 Title: Interface for Proposal Proposals are the defacto heart of the protocol since they allow voting token holders potentially alter all of the logic of a DFO and even extend it via custom logic. Methods accept(uint256) Vote to accept the Proposal, staking your voting tokens. Can be called only if the Proposal is still running. disable() Can be used by external Proposal Managers to disable not-yet started Surveys getCodeName() GET the Proposal Functionality string ID getLocation() GET address of the microservice getMethodSignature() GET the name of the microservice method to invoke getProposer() GET the address of the proposer getProxy() GET the Proxy address getReplaces() codeName of the microservice that will be replaced by this Proposal, can be blank. getReturnAbiParametersArray() GET the array of return values obtained from the called microservice's method getSourceLocation() GET the Location of the source code, saved in concatenated Base64 data chunks getSourceLocationId() GET the Base64 data chunk id of the corresponding Microservice getSurveyDuration() GET the duration of the Proposal in number of blocks getSurveyEndBlock() GET The proposal end block getVote(address) GET the current status of the voting of the given address Params addr : The address of the voter you want to know status Returns accept : Amount of YES votes refuse : Amount of NO votes getVotes() Get the current votes status Returns _0 : accept Amount of YES votes _1 : refuse Amount of NO votes getVotesHardCapToReach() GET the HardCap value init(string,address,string,string,string,address) Functionality Initializer Params codeName : ID of the microservice, to be called by the user through Proxy, can be blank. location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call proxy : Address of the proxy replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method isDisabled() Check if a Proposal was canceled before its start isEmergency() GET the boolean flag indicating wether the Proposal is an Emergency Proposal isInternal() GET the boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) isTerminated() Check if the Proposal reached the natural time termination or the reachement of the Hard Cap. isVotesHardCapReached() Check that the HardCap has been reached issubmittable() GET the boolean flag controlling wether the microservice writes data to the chain moveToAccept(uint256) Move some \"refuse\" votes to \"accept\". Can be called only if the Proposal is still running. moveToRefuse(uint256) Move some \"accept\" votes to \"refuse\". Can be called only if the Proposal is still running. needsSender() GET the boolean flag controlling wether the original Proxy caller address should be forwarded or not refuse(uint256) Vote to refuse the Proposal, staking your voting tokens. Can be called only if the Proposal is still running. retireAccept(uint256) Retire your votes. Can be called only if the Proposal is still running. retireAll() Retire all your votes, retreiving back your staked voting tokens. Can be called only if the Proposal is still running. retireRefuse(uint256) Retire your votes. Can be called only if the Proposal is still running. set() Callable by the Proxy only. Marks this Proposal as definitively terminate. User can still call the withdrawAll() function to withdraw the tokens, of course. setCollateralData(bool,address,uint256,bool,bool,bool,address,uint256) set the collateral attributes of the proposal Params emergency : Bool flag controlling wether this is a standard or emergency proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place proposer : Address of the proposer sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain votesHardCap : Hardcap value start() Can be used by external Proposal Managers to delay the Survey Start terminate() Force the Proposal to call the Proxy and execute the finalization operations. Can be called only if the Proposal reaches the Hard Cap or the final Block. toJSON() GET the json representation of the Functionality withdraw() Withdraw all the token you staked. Can be called only if the Proposal reaches the Hard Cap or the final Block.","title":"IMVDFunctionalityProposal"},{"location":"contracts/IMVDFunctionalityProposal/#contract-imvdfunctionalityproposal","text":"Path: contracts/IMVDFunctionalityProposal.sol Version: 1 Title: Interface for Proposal Proposals are the defacto heart of the protocol since they allow voting token holders potentially alter all of the logic of a DFO and even extend it via custom logic.","title":"Contract IMVDFunctionalityProposal"},{"location":"contracts/IMVDFunctionalityProposal/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalityProposal/#acceptuint256","text":"Vote to accept the Proposal, staking your voting tokens. Can be called only if the Proposal is still running.","title":"accept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#disable","text":"Can be used by external Proposal Managers to disable not-yet started Surveys","title":"disable()"},{"location":"contracts/IMVDFunctionalityProposal/#getcodename","text":"GET the Proposal Functionality string ID","title":"getCodeName()"},{"location":"contracts/IMVDFunctionalityProposal/#getlocation","text":"GET address of the microservice","title":"getLocation()"},{"location":"contracts/IMVDFunctionalityProposal/#getmethodsignature","text":"GET the name of the microservice method to invoke","title":"getMethodSignature()"},{"location":"contracts/IMVDFunctionalityProposal/#getproposer","text":"GET the address of the proposer","title":"getProposer()"},{"location":"contracts/IMVDFunctionalityProposal/#getproxy","text":"GET the Proxy address","title":"getProxy()"},{"location":"contracts/IMVDFunctionalityProposal/#getreplaces","text":"codeName of the microservice that will be replaced by this Proposal, can be blank.","title":"getReplaces()"},{"location":"contracts/IMVDFunctionalityProposal/#getreturnabiparametersarray","text":"GET the array of return values obtained from the called microservice's method","title":"getReturnAbiParametersArray()"},{"location":"contracts/IMVDFunctionalityProposal/#getsourcelocation","text":"GET the Location of the source code, saved in concatenated Base64 data chunks","title":"getSourceLocation()"},{"location":"contracts/IMVDFunctionalityProposal/#getsourcelocationid","text":"GET the Base64 data chunk id of the corresponding Microservice","title":"getSourceLocationId()"},{"location":"contracts/IMVDFunctionalityProposal/#getsurveyduration","text":"GET the duration of the Proposal in number of blocks","title":"getSurveyDuration()"},{"location":"contracts/IMVDFunctionalityProposal/#getsurveyendblock","text":"GET The proposal end block","title":"getSurveyEndBlock()"},{"location":"contracts/IMVDFunctionalityProposal/#getvoteaddress","text":"GET the current status of the voting of the given address","title":"getVote(address)"},{"location":"contracts/IMVDFunctionalityProposal/#params","text":"addr : The address of the voter you want to know status","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#returns","text":"accept : Amount of YES votes refuse : Amount of NO votes","title":"Returns"},{"location":"contracts/IMVDFunctionalityProposal/#getvotes","text":"Get the current votes status","title":"getVotes()"},{"location":"contracts/IMVDFunctionalityProposal/#returns_1","text":"_0 : accept Amount of YES votes _1 : refuse Amount of NO votes","title":"Returns"},{"location":"contracts/IMVDFunctionalityProposal/#getvoteshardcaptoreach","text":"GET the HardCap value","title":"getVotesHardCapToReach()"},{"location":"contracts/IMVDFunctionalityProposal/#initstringaddressstringstringstringaddress","text":"Functionality Initializer","title":"init(string,address,string,string,string,address)"},{"location":"contracts/IMVDFunctionalityProposal/#params_1","text":"codeName : ID of the microservice, to be called by the user through Proxy, can be blank. location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call proxy : Address of the proxy replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#isdisabled","text":"Check if a Proposal was canceled before its start","title":"isDisabled()"},{"location":"contracts/IMVDFunctionalityProposal/#isemergency","text":"GET the boolean flag indicating wether the Proposal is an Emergency Proposal","title":"isEmergency()"},{"location":"contracts/IMVDFunctionalityProposal/#isinternal","text":"GET the boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true)","title":"isInternal()"},{"location":"contracts/IMVDFunctionalityProposal/#isterminated","text":"Check if the Proposal reached the natural time termination or the reachement of the Hard Cap.","title":"isTerminated()"},{"location":"contracts/IMVDFunctionalityProposal/#isvoteshardcapreached","text":"Check that the HardCap has been reached","title":"isVotesHardCapReached()"},{"location":"contracts/IMVDFunctionalityProposal/#issubmittable","text":"GET the boolean flag controlling wether the microservice writes data to the chain","title":"issubmittable()"},{"location":"contracts/IMVDFunctionalityProposal/#movetoacceptuint256","text":"Move some \"refuse\" votes to \"accept\". Can be called only if the Proposal is still running.","title":"moveToAccept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#movetorefuseuint256","text":"Move some \"accept\" votes to \"refuse\". Can be called only if the Proposal is still running.","title":"moveToRefuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#needssender","text":"GET the boolean flag controlling wether the original Proxy caller address should be forwarded or not","title":"needsSender()"},{"location":"contracts/IMVDFunctionalityProposal/#refuseuint256","text":"Vote to refuse the Proposal, staking your voting tokens. Can be called only if the Proposal is still running.","title":"refuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#retireacceptuint256","text":"Retire your votes. Can be called only if the Proposal is still running.","title":"retireAccept(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#retireall","text":"Retire all your votes, retreiving back your staked voting tokens. Can be called only if the Proposal is still running.","title":"retireAll()"},{"location":"contracts/IMVDFunctionalityProposal/#retirerefuseuint256","text":"Retire your votes. Can be called only if the Proposal is still running.","title":"retireRefuse(uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#set","text":"Callable by the Proxy only. Marks this Proposal as definitively terminate. User can still call the withdrawAll() function to withdraw the tokens, of course.","title":"set()"},{"location":"contracts/IMVDFunctionalityProposal/#setcollateraldatabooladdressuint256boolboolbooladdressuint256","text":"set the collateral attributes of the proposal","title":"setCollateralData(bool,address,uint256,bool,bool,bool,address,uint256)"},{"location":"contracts/IMVDFunctionalityProposal/#params_2","text":"emergency : Bool flag controlling wether this is a standard or emergency proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) needsSender : All microservices calls are made py the Proxy, with this boolean flag you can forward the address that called the Proxy in the first place proposer : Address of the proposer sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain votesHardCap : Hardcap value","title":"Params"},{"location":"contracts/IMVDFunctionalityProposal/#start","text":"Can be used by external Proposal Managers to delay the Survey Start","title":"start()"},{"location":"contracts/IMVDFunctionalityProposal/#terminate","text":"Force the Proposal to call the Proxy and execute the finalization operations. Can be called only if the Proposal reaches the Hard Cap or the final Block.","title":"terminate()"},{"location":"contracts/IMVDFunctionalityProposal/#tojson","text":"GET the json representation of the Functionality","title":"toJSON()"},{"location":"contracts/IMVDFunctionalityProposal/#withdraw","text":"Withdraw all the token you staked. Can be called only if the Proposal reaches the Hard Cap or the final Block.","title":"withdraw()"},{"location":"contracts/IMVDFunctionalityProposalManager/","text":"Contract IMVDFunctionalityProposalManager Path: contracts/IMVDFunctionalityProposalManager.sol Version: 1 Title: Functionality Proposal Manager Microservice for adding new proposals Methods checkProposal(address) Callable by the Proxy only. Contains the logic to check if a proposal is ready to be finalized (e.g. last block reached or hard cap reached). getProxy() GET the Proxy contract address isValidProposal(address) Check that a proposal is valid Params proposal : Address of the proposal to check Returns isValid : Boolean indicating the validity of the function newProposal(string,address,string,string,string) Add a new Proposal Work explanation: codeName is set and replaces is blank: the Proposal will add a new Microservice/Functionality codeName is blank and replaces is set: the Proposal will remove an existing Microservice/Functionality codeName and replaces are both set: the Proposal will replace an existing Functionality/Microservice with a new one codeName and replaces are both blank: the Proposal represents a One-Time Functionality, that will be executed just one time, if the Token Holders Pccepts this proposal. Params codeName : ID of the microservice, to be called by the user through Proxy, can be blank. location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method Returns proposal : Address of the newly added proposal setProxy() SET the Proxy contract address","title":"IMVDFunctionalityProposalManager"},{"location":"contracts/IMVDFunctionalityProposalManager/#contract-imvdfunctionalityproposalmanager","text":"Path: contracts/IMVDFunctionalityProposalManager.sol Version: 1 Title: Functionality Proposal Manager Microservice for adding new proposals","title":"Contract IMVDFunctionalityProposalManager"},{"location":"contracts/IMVDFunctionalityProposalManager/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDFunctionalityProposalManager/#checkproposaladdress","text":"Callable by the Proxy only. Contains the logic to check if a proposal is ready to be finalized (e.g. last block reached or hard cap reached).","title":"checkProposal(address)"},{"location":"contracts/IMVDFunctionalityProposalManager/#getproxy","text":"GET the Proxy contract address","title":"getProxy()"},{"location":"contracts/IMVDFunctionalityProposalManager/#isvalidproposaladdress","text":"Check that a proposal is valid","title":"isValidProposal(address)"},{"location":"contracts/IMVDFunctionalityProposalManager/#params","text":"proposal : Address of the proposal to check","title":"Params"},{"location":"contracts/IMVDFunctionalityProposalManager/#returns","text":"isValid : Boolean indicating the validity of the function","title":"Returns"},{"location":"contracts/IMVDFunctionalityProposalManager/#newproposalstringaddressstringstringstring","text":"Add a new Proposal Work explanation: codeName is set and replaces is blank: the Proposal will add a new Microservice/Functionality codeName is blank and replaces is set: the Proposal will remove an existing Microservice/Functionality codeName and replaces are both set: the Proposal will replace an existing Functionality/Microservice with a new one codeName and replaces are both blank: the Proposal represents a One-Time Functionality, that will be executed just one time, if the Token Holders Pccepts this proposal.","title":"newProposal(string,address,string,string,string)"},{"location":"contracts/IMVDFunctionalityProposalManager/#params_1","text":"codeName : ID of the microservice, to be called by the user through Proxy, can be blank. location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnAbiParametersArray : Array of return values obtained from the called microservice's method","title":"Params"},{"location":"contracts/IMVDFunctionalityProposalManager/#returns_1","text":"proposal : Address of the newly added proposal","title":"Returns"},{"location":"contracts/IMVDFunctionalityProposalManager/#setproxy","text":"SET the Proxy contract address","title":"setProxy()"},{"location":"contracts/IMVDProxy/","text":"Contract IMVDProxy Path: contracts/IMVDProxy.sol Version: 1 Title: Proxy Interface Methods callFromManager(address,bytes) callable by the MVDFunctionalitiesManager only. Calls a Microservice using the Proxy as msg.sender disableProposal(address) Can be used by external Proposal Managers to disable not-yet started Surveys emitEvent(string,bytes,bytes,bytes) callable by Microservices only. Emits the general purpose \"Event\" event by the Proxy emitFromManager(string,address,string,address,uint256,address,bool,string,bool,bool,address) callable by the MVDFunctionalitiesManager only. Emits the FunctionalitySet event by the Proxy flushToWallet(address,bool,uint256) Utility public method callable by everyone to send all ether/tokens/NFT accidentally sent to the Proxy. It flushes all in the DFO Wallet Params is721 : tokenAddress is 721 or ERC20 tokenAddress : the ERC20/ERC721 token to transfer. address(0) means flush ether tokenId : the id of the eventual ERC721 Token to transfer getDoubleProxyAddress() GET the Double Proxy contract address getMVDFunctionalitiesManagerAddress() GET the Functionalities Manager contract address getMVDFunctionalityModelsManagerAddress() GET the Functionality Models Manager contract address getMVDFunctionalityProposalManagerAddress() GET the Functionality Proposal Manager contract address getMVDWalletAddress() GET the Wallet contract address getStateHolderAddress() GET the State Holder contract address getToken() GET the voting token contract address init(address,address,address,address,address,address,address) Initialization logic used during the constructor call Params doubleProxyAddress : Address of the double proxy functionalitiesManagerAddress : Address of the Functionalities Manager functionalityModelsManagerAddress : Address of the Functionality Models Manager functionalityProposalManagerAddress : Address of the Functionality Proposal Manager stateHolderAddress : Address of the State Holder contract votingTokenAddress : Address of the Voting Token walletAddress : Address of the wallet newProposal(string,bool,address,uint256,address,bool,string,string,bool,bool,string) Add a new proposal Params codeName : ID of the microservice, to be called by the user through Proxy, can be blank. emergency : Boolean, true -> Emergency Proposal, false -> Standard Proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnParametersJSONArray : Array of json encoded return parameters of the proposal sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain Returns proposalAddress : Address of the newly created proposal read(string,bytes) Call a non-submitable (readonly function marked as pure or view) Microservice Params codeName : the ID of the Microservice to be called data : ABI encoded data payload to be passed to the Microservice setProposal() Callable by the Proposals only. Starts the Proposal finalization procedure startProposal(address) Can be used by external Proposal Managers to delay the Survey Start submit(string,bytes) Call a submitable (which writes on the Blockchain State) Microservice Params codeName : the ID of the Microservice to be called data : ABI encoded data payload to be passed to the Microservice transfer(address,uint256,address) Transfer a token to an address Params receiver : Address of the receiver token : Address of the token to transfer value : Amount of token to transfer transfer721(address,uint256,bytes,bool,address) Transfer an ERC721 to an address Params data : The optional payload to pass in the safeTransferFrom function receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"IMVDProxy"},{"location":"contracts/IMVDProxy/#contract-imvdproxy","text":"Path: contracts/IMVDProxy.sol Version: 1 Title: Proxy Interface","title":"Contract IMVDProxy"},{"location":"contracts/IMVDProxy/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDProxy/#callfrommanageraddressbytes","text":"callable by the MVDFunctionalitiesManager only. Calls a Microservice using the Proxy as msg.sender","title":"callFromManager(address,bytes)"},{"location":"contracts/IMVDProxy/#disableproposaladdress","text":"Can be used by external Proposal Managers to disable not-yet started Surveys","title":"disableProposal(address)"},{"location":"contracts/IMVDProxy/#emiteventstringbytesbytesbytes","text":"callable by Microservices only. Emits the general purpose \"Event\" event by the Proxy","title":"emitEvent(string,bytes,bytes,bytes)"},{"location":"contracts/IMVDProxy/#emitfrommanagerstringaddressstringaddressuint256addressboolstringboolbooladdress","text":"callable by the MVDFunctionalitiesManager only. Emits the FunctionalitySet event by the Proxy","title":"emitFromManager(string,address,string,address,uint256,address,bool,string,bool,bool,address)"},{"location":"contracts/IMVDProxy/#flushtowalletaddressbooluint256","text":"Utility public method callable by everyone to send all ether/tokens/NFT accidentally sent to the Proxy. It flushes all in the DFO Wallet","title":"flushToWallet(address,bool,uint256)"},{"location":"contracts/IMVDProxy/#params","text":"is721 : tokenAddress is 721 or ERC20 tokenAddress : the ERC20/ERC721 token to transfer. address(0) means flush ether tokenId : the id of the eventual ERC721 Token to transfer","title":"Params"},{"location":"contracts/IMVDProxy/#getdoubleproxyaddress","text":"GET the Double Proxy contract address","title":"getDoubleProxyAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalitiesmanageraddress","text":"GET the Functionalities Manager contract address","title":"getMVDFunctionalitiesManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalitymodelsmanageraddress","text":"GET the Functionality Models Manager contract address","title":"getMVDFunctionalityModelsManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdfunctionalityproposalmanageraddress","text":"GET the Functionality Proposal Manager contract address","title":"getMVDFunctionalityProposalManagerAddress()"},{"location":"contracts/IMVDProxy/#getmvdwalletaddress","text":"GET the Wallet contract address","title":"getMVDWalletAddress()"},{"location":"contracts/IMVDProxy/#getstateholderaddress","text":"GET the State Holder contract address","title":"getStateHolderAddress()"},{"location":"contracts/IMVDProxy/#gettoken","text":"GET the voting token contract address","title":"getToken()"},{"location":"contracts/IMVDProxy/#initaddressaddressaddressaddressaddressaddressaddress","text":"Initialization logic used during the constructor call","title":"init(address,address,address,address,address,address,address)"},{"location":"contracts/IMVDProxy/#params_1","text":"doubleProxyAddress : Address of the double proxy functionalitiesManagerAddress : Address of the Functionalities Manager functionalityModelsManagerAddress : Address of the Functionality Models Manager functionalityProposalManagerAddress : Address of the Functionality Proposal Manager stateHolderAddress : Address of the State Holder contract votingTokenAddress : Address of the Voting Token walletAddress : Address of the wallet","title":"Params"},{"location":"contracts/IMVDProxy/#newproposalstringbooladdressuint256addressboolstringstringboolboolstring","text":"Add a new proposal","title":"newProposal(string,bool,address,uint256,address,bool,string,string,bool,bool,string)"},{"location":"contracts/IMVDProxy/#params_2","text":"codeName : ID of the microservice, to be called by the user through Proxy, can be blank. emergency : Boolean, true -> Emergency Proposal, false -> Standard Proposal isInternal : Boolean flag controlling wether the microservice can be called from anyone (false) or can be called only by other microservices (true) location : Address of the functionality/microservice to call methodSignature : Name of the method of the microservice you want to call needsSender : All microservices calls are made py the Proxy, with this boolean flag you can replaces : codeName of the microservice that will be replaced by this Proposal, can be blank. returnParametersJSONArray : Array of json encoded return parameters of the proposal sourceLocation : Location of the source code, saved in concatenated Base64 data chunks sourceLocationId : Base64 data chunk id of the corresponding Microservice submittable : Boolean flag controlling wether the microservice writes data to the chain","title":"Params"},{"location":"contracts/IMVDProxy/#returns","text":"proposalAddress : Address of the newly created proposal","title":"Returns"},{"location":"contracts/IMVDProxy/#readstringbytes","text":"Call a non-submitable (readonly function marked as pure or view) Microservice","title":"read(string,bytes)"},{"location":"contracts/IMVDProxy/#params_3","text":"codeName : the ID of the Microservice to be called data : ABI encoded data payload to be passed to the Microservice","title":"Params"},{"location":"contracts/IMVDProxy/#setproposal","text":"Callable by the Proposals only. Starts the Proposal finalization procedure","title":"setProposal()"},{"location":"contracts/IMVDProxy/#startproposaladdress","text":"Can be used by external Proposal Managers to delay the Survey Start","title":"startProposal(address)"},{"location":"contracts/IMVDProxy/#submitstringbytes","text":"Call a submitable (which writes on the Blockchain State) Microservice","title":"submit(string,bytes)"},{"location":"contracts/IMVDProxy/#params_4","text":"codeName : the ID of the Microservice to be called data : ABI encoded data payload to be passed to the Microservice","title":"Params"},{"location":"contracts/IMVDProxy/#transferaddressuint256address","text":"Transfer a token to an address","title":"transfer(address,uint256,address)"},{"location":"contracts/IMVDProxy/#params_5","text":"receiver : Address of the receiver token : Address of the token to transfer value : Amount of token to transfer","title":"Params"},{"location":"contracts/IMVDProxy/#transfer721addressuint256bytesbooladdress","text":"Transfer an ERC721 to an address","title":"transfer721(address,uint256,bytes,bool,address)"},{"location":"contracts/IMVDProxy/#params_6","text":"data : The optional payload to pass in the safeTransferFrom function receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IMVDWallet/","text":"Contract IMVDWallet Path: contracts/IMVDWallet.sol Version: 1 Title: Wallet The wallet is used to store all the assets of a DFO (ethers, ERC20 Tokens, ERC721 NFTs). All the functions to transfer assets can be called by the Proxy only. Methods flush721ToNewWallet(uint256,bytes,bool,address) Transfer an ERC721 to the NewWallet Params data : The optional payload passed in the safeTransferFrom function safe : Boolean flag for triggering the SafeTransfer tokenAddress : Address of the token to transfer tokenId : ID of the ERC721 to transfer flushToNewWallet(address) Send all of the specified tokens to the NewWallet Params token : Address of the token to send getProxy() GET the proxy address setNewWallet(address,address) SET new wallet Params newWallet : New wallet address tokenAddress : The voting token, used to flush balance to new wallet setProxy() SET the proxy address transfer(address,uint256,address) Transfer a token to an address Params receiver : Address of the receiver tokenAddress : Address of the token to transfer value : Amount of token to transfer transfer(address,uint256,bytes,bool,address) Transfer an ERC721 to an address Params data : The optional payload to pass in the safeTransferFrom function receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"IMVDWallet"},{"location":"contracts/IMVDWallet/#contract-imvdwallet","text":"Path: contracts/IMVDWallet.sol Version: 1 Title: Wallet The wallet is used to store all the assets of a DFO (ethers, ERC20 Tokens, ERC721 NFTs). All the functions to transfer assets can be called by the Proxy only.","title":"Contract IMVDWallet"},{"location":"contracts/IMVDWallet/#methods","text":"","title":"Methods"},{"location":"contracts/IMVDWallet/#flush721tonewwalletuint256bytesbooladdress","text":"Transfer an ERC721 to the NewWallet","title":"flush721ToNewWallet(uint256,bytes,bool,address)"},{"location":"contracts/IMVDWallet/#params","text":"data : The optional payload passed in the safeTransferFrom function safe : Boolean flag for triggering the SafeTransfer tokenAddress : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IMVDWallet/#flushtonewwalletaddress","text":"Send all of the specified tokens to the NewWallet","title":"flushToNewWallet(address)"},{"location":"contracts/IMVDWallet/#params_1","text":"token : Address of the token to send","title":"Params"},{"location":"contracts/IMVDWallet/#getproxy","text":"GET the proxy address","title":"getProxy()"},{"location":"contracts/IMVDWallet/#setnewwalletaddressaddress","text":"SET new wallet","title":"setNewWallet(address,address)"},{"location":"contracts/IMVDWallet/#params_2","text":"newWallet : New wallet address tokenAddress : The voting token, used to flush balance to new wallet","title":"Params"},{"location":"contracts/IMVDWallet/#setproxy","text":"SET the proxy address","title":"setProxy()"},{"location":"contracts/IMVDWallet/#transferaddressuint256address","text":"Transfer a token to an address","title":"transfer(address,uint256,address)"},{"location":"contracts/IMVDWallet/#params_3","text":"receiver : Address of the receiver tokenAddress : Address of the token to transfer value : Amount of token to transfer","title":"Params"},{"location":"contracts/IMVDWallet/#transferaddressuint256bytesbooladdress","text":"Transfer an ERC721 to an address","title":"transfer(address,uint256,bytes,bool,address)"},{"location":"contracts/IMVDWallet/#params_4","text":"data : The optional payload to pass in the safeTransferFrom function receiver : Address of the receiver safe : Boolean flag for triggering the SafeTransfer token : Address of the token to transfer tokenId : ID of the ERC721 to transfer","title":"Params"},{"location":"contracts/IStateHolder/","text":"Contract IStateHolder Path: contracts/IStateHolder.sol Version: 1 Title: State Holder StateHolder is the Database of a DFO. It stores all data the DFO needs to run its business logic. It works like a Key/Value storage and can save the main Solidity data types (address, bool, uint256, string, bytes). The read capabilities are of course public. While se write capabilities (set/clear) can be called by DFO Microservices only. The set methods also return the previous value of the set variable Methods clear(string) delete the variable from the StateHolder Params varName : the name of the variable to delete Returns oldDataType : the data type of the deleted variable oldVal : the old value of the deleted variable exists(string) Params varName : the name of the variable to check Returns _0 : true if varName is set, false otherwhise getDataType(string) Params varName : the name of the variable to check Returns dataType : the data type of this var, if any. getProxy() GET the Proxy getStateSize() returns the number of values set in the StateHolder init() Initialization logic using during the constructor Call setProxy() SET the Proxy toJSON() For frontend purposes. Returns the StateHolder's keys and values in JSON Format toJSON(uint256,uint256) For frontend purposes. Returns the StateHolder's keys and values in JSON Format Params l : the values array offset start : the values array start","title":"IStateHolder"},{"location":"contracts/IStateHolder/#contract-istateholder","text":"Path: contracts/IStateHolder.sol Version: 1 Title: State Holder StateHolder is the Database of a DFO. It stores all data the DFO needs to run its business logic. It works like a Key/Value storage and can save the main Solidity data types (address, bool, uint256, string, bytes). The read capabilities are of course public. While se write capabilities (set/clear) can be called by DFO Microservices only. The set methods also return the previous value of the set variable","title":"Contract IStateHolder"},{"location":"contracts/IStateHolder/#methods","text":"","title":"Methods"},{"location":"contracts/IStateHolder/#clearstring","text":"delete the variable from the StateHolder","title":"clear(string)"},{"location":"contracts/IStateHolder/#params","text":"varName : the name of the variable to delete","title":"Params"},{"location":"contracts/IStateHolder/#returns","text":"oldDataType : the data type of the deleted variable oldVal : the old value of the deleted variable","title":"Returns"},{"location":"contracts/IStateHolder/#existsstring","text":"","title":"exists(string)"},{"location":"contracts/IStateHolder/#params_1","text":"varName : the name of the variable to check","title":"Params"},{"location":"contracts/IStateHolder/#returns_1","text":"_0 : true if varName is set, false otherwhise","title":"Returns"},{"location":"contracts/IStateHolder/#getdatatypestring","text":"","title":"getDataType(string)"},{"location":"contracts/IStateHolder/#params_2","text":"varName : the name of the variable to check","title":"Params"},{"location":"contracts/IStateHolder/#returns_2","text":"dataType : the data type of this var, if any.","title":"Returns"},{"location":"contracts/IStateHolder/#getproxy","text":"GET the Proxy","title":"getProxy()"},{"location":"contracts/IStateHolder/#getstatesize","text":"returns the number of values set in the StateHolder","title":"getStateSize()"},{"location":"contracts/IStateHolder/#init","text":"Initialization logic using during the constructor Call","title":"init()"},{"location":"contracts/IStateHolder/#setproxy","text":"SET the Proxy","title":"setProxy()"},{"location":"contracts/IStateHolder/#tojson","text":"For frontend purposes. Returns the StateHolder's keys and values in JSON Format","title":"toJSON()"},{"location":"contracts/IStateHolder/#tojsonuint256uint256","text":"For frontend purposes. Returns the StateHolder's keys and values in JSON Format","title":"toJSON(uint256,uint256)"},{"location":"contracts/IStateHolder/#params_3","text":"l : the values array offset start : the values array start","title":"Params"},{"location":"contracts/IVotingToken/","text":"Contract IVotingToken Path: contracts/IVotingToken.sol Version: 1 Title: Voting Token interface Methods burn(uint256) Burn functionality of the voting token decimals() GET amount of decimals supported by the token decreaseAllowance(address,uint256) see the OpenZeppelin's documentation getProxy() GET the Proxy increaseAllowance(address,uint256) see the OpenZeppelin's documentation init(string,string,uint256,uint256) Initialization logic using during the constructor Call Params decimals : Amount of decimals supported by the token name : Name of the token used symbol : Ticker symbol of the token used totalSupply : Total Supply of the token mint(uint256) Mint functionality of the voting token name() GET the token name setProxy() SET the Proxy symbol() GET the token ticker symbol","title":"IVotingToken"},{"location":"contracts/IVotingToken/#contract-ivotingtoken","text":"Path: contracts/IVotingToken.sol Version: 1 Title: Voting Token interface","title":"Contract IVotingToken"},{"location":"contracts/IVotingToken/#methods","text":"","title":"Methods"},{"location":"contracts/IVotingToken/#burnuint256","text":"Burn functionality of the voting token","title":"burn(uint256)"},{"location":"contracts/IVotingToken/#decimals","text":"GET amount of decimals supported by the token","title":"decimals()"},{"location":"contracts/IVotingToken/#decreaseallowanceaddressuint256","text":"see the OpenZeppelin's documentation","title":"decreaseAllowance(address,uint256)"},{"location":"contracts/IVotingToken/#getproxy","text":"GET the Proxy","title":"getProxy()"},{"location":"contracts/IVotingToken/#increaseallowanceaddressuint256","text":"see the OpenZeppelin's documentation","title":"increaseAllowance(address,uint256)"},{"location":"contracts/IVotingToken/#initstringstringuint256uint256","text":"Initialization logic using during the constructor Call","title":"init(string,string,uint256,uint256)"},{"location":"contracts/IVotingToken/#params","text":"decimals : Amount of decimals supported by the token name : Name of the token used symbol : Ticker symbol of the token used totalSupply : Total Supply of the token","title":"Params"},{"location":"contracts/IVotingToken/#mintuint256","text":"Mint functionality of the voting token","title":"mint(uint256)"},{"location":"contracts/IVotingToken/#name","text":"GET the token name","title":"name()"},{"location":"contracts/IVotingToken/#setproxy","text":"SET the Proxy","title":"setProxy()"},{"location":"contracts/IVotingToken/#symbol","text":"GET the token ticker symbol","title":"symbol()"}]}